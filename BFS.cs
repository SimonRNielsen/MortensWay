using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;

namespace MortensWay
{
    internal static class BFS
    {


        public static Tile BFSMethod(Tile startNode, Tile endNode)
        {
            //ChatGPTs solution:
            Queue<Tile> queue = new Queue<Tile>();
            startNode.Discovered = true;
            queue.Enqueue(startNode);
            while(queue.Count >0)
            {
                Tile currentTile = queue.Dequeue();
                if (currentTile == endNode)
                {
                    return currentTile;
                }
                foreach (Edge e in currentTile.Edges)
                {
                    Tile neighbor = e.To;
                    if(!neighbor.Discovered)
                    {
                        neighbor.Discovered = true;
                        neighbor.Parent = currentTile;
                        queue.Enqueue(neighbor);
                    }
                }

            }

            /*The following is BFS as demonstrated in the asignment, but it creates an infinite loop:
             *     
            Queue<Edge> stack = new Queue<Edge>();
            Edge startEdge = new Edge(0, startNode, startNode);
            stack.Enqueue(startEdge);

            while (stack.Count > 0)
            {
                Edge edge = stack.Dequeue();
                if (!edge.To.Discovered)
                {
                    edge.To.Discovered = true;
                    edge.To.Parent = edge.From;
                }
                if (edge.To == endNode)
                {
                    return edge.To;
                }
                foreach (Edge e in edge.To.Edges)
                {
                    if (!e.To.Discovered)
                    {
                        stack.Enqueue(e);
                    }
                }
            }*/
            return null;

        }
        /// <summary>
        /// Returns a list of tiles, following the path generated by the BFSMethod.
        /// </summary>
        /// <param name="endNode">The tile where the BFS ended</param>
        /// <param name="startNode">The Tile where the BFS started.</param>
        /// <returns></returns>
        public static List<Tile> FindPath(Tile endNode, Tile startNode)
        {
            List<Tile> pathOfNodes = new List<Tile>();
            pathOfNodes.Add(endNode);
            while (endNode != startNode)
            {

                pathOfNodes.Add(endNode.Parent);
                endNode = endNode.Parent;
            }
            pathOfNodes.Reverse();
            return pathOfNodes;
        }







        public static void StartBFS()
        {
            Tile startNode = (Tile)(GameWorld.gameObjects.Find(x => (TileTypes)x.Type == TileTypes.Portal));
            Tile endNode = (Tile)(GameWorld.gameObjects.Find(x => (TileTypes)x.Type == (TileTypes)TileTypes.TowerKey));
            BFS.BFSMethod(startNode, endNode);
            List<Tile> pathTest = BFS.FindPath(endNode, startNode);
            foreach (Tile item in pathTest)
            {
                item.Color = Color.LightBlue;
            }
        }

    }

}

